package com.example.reservation.benchmark

import com.example.reservation.controller.CreateReservationRequest
import kotlinx.coroutines.*
import org.springframework.boot.CommandLineRunner
import org.springframework.http.*
import org.springframework.stereotype.Component
import org.springframework.web.client.RestTemplate
import org.springframework.web.reactive.function.client.WebClient
import org.springframework.web.reactive.function.client.awaitBody
import reactor.core.publisher.Mono
import java.time.Duration
import java.time.LocalDateTime
import java.util.concurrent.ConcurrentHashMap
import java.util.concurrent.atomic.AtomicInteger
import java.util.concurrent.atomic.AtomicLong
import kotlin.random.Random
import kotlin.system.measureTimeMillis

/**
 * API ÏùëÎãµ ÏãúÍ∞Ñ ÎπÑÍµê ÎèÑÍµ¨
 * MVC vs WebFlux ÏÑ±Îä•ÏùÑ Ïã§Ï†ú HTTP ÏöîÏ≤≠ÏúºÎ°ú ÎπÑÍµê Ï∏°Ï†ï
 */
@Component 
class ApiResponseTimeComparator(
) : CommandLineRunner {

    private val restTemplate = RestTemplate().apply {
        // Ïó∞Í≤∞ ÌÉÄÏûÑÏïÑÏõÉ ÏÑ§Ï†ï
        requestFactory = org.springframework.http.client.SimpleClientHttpRequestFactory().apply {
            setConnectTimeout(5000)
            setReadTimeout(10000)
        }
    }
    
    private val webClient = WebClient.builder()
        .baseUrl("http://localhost:8080")
        .codecs { it.defaultCodecs().maxInMemorySize(1024 * 1024) }
        .build()

    data class ApiEndpoint(
        val name: String,
        val path: String,
        val type: ApiType,
        val language: Language
    )

    enum class ApiType { MVC, WEBFLUX }
    enum class Language { KOTLIN, JAVA }

    data class ResponseTimeResult(
        val endpoint: ApiEndpoint,
        val totalRequests: Int,
        val successfulRequests: AtomicInteger = AtomicInteger(0),
        val failedRequests: AtomicInteger = AtomicInteger(0),
        val totalResponseTime: AtomicLong = AtomicLong(0),
        val minResponseTime: AtomicLong = AtomicLong(Long.MAX_VALUE),
        val maxResponseTime: AtomicLong = AtomicLong(0),
        val responseTimes: ConcurrentHashMap<Long, Int> = ConcurrentHashMap(), // ÏùëÎãµÏãúÍ∞Ñ Î∂ÑÌè¨
        val errorMessages: ConcurrentHashMap<String, AtomicInteger> = ConcurrentHashMap()
    ) {
        fun getAverageResponseTime(): Double = 
            if (successfulRequests.get() > 0) totalResponseTime.get().toDouble() / successfulRequests.get() 
            else 0.0
        
        fun getSuccessRate(): Double = 
            if (totalRequests > 0) successfulRequests.get().toDouble() / totalRequests * 100 
            else 0.0
        
        fun getThroughput(): Double = 
            if (totalResponseTime.get() > 0) successfulRequests.get().toDouble() / (totalResponseTime.get() / 1000.0) 
            else 0.0
    }

    override fun run(vararg args: String?) {
        if (args.contains("--response-time-comparison")) {
            println("üìä API ÏùëÎãµ ÏãúÍ∞Ñ ÎπÑÍµê Î∂ÑÏÑù ÏãúÏûë...")
            runResponseTimeComparison()
        }
    }

    fun runResponseTimeComparison() {
        val endpoints = listOf(
            ApiEndpoint("Kotlin MVC", "/api/reservations", ApiType.MVC, Language.KOTLIN),
            ApiEndpoint("Kotlin WebFlux", "/api/webflux/reservations", ApiType.WEBFLUX, Language.KOTLIN),
            ApiEndpoint("Java MVC", "/api/java/reservations", ApiType.MVC, Language.JAVA),
            ApiEndpoint("Java WebFlux", "/api/webflux-java/reservations", ApiType.WEBFLUX, Language.JAVA)
        )

        println("üöÄ ÏùëÎãµ ÏãúÍ∞Ñ ÎπÑÍµê ÌÖåÏä§Ìä∏ ÏãúÏûë (${LocalDateTime.now()})")
        println("=" * 80)

        val results = runBlocking {
            endpoints.map { endpoint ->
                async(Dispatchers.IO) {
                    println("üîÑ ${endpoint.name} ÌÖåÏä§Ìä∏ ÏãúÏûë...")
                    measureApiResponseTime(endpoint)
                }
            }.awaitAll()
        }

        // Í≤∞Í≥º Î∂ÑÏÑù Î∞è Ï∂úÎ†•
        analyzeAndPrintResults(results)
    }

    private suspend fun measureApiResponseTime(endpoint: ApiEndpoint): ResponseTimeResult {
        val testConfigurations = listOf(
            TestConfig("Îã®Ïùº ÏöîÏ≤≠", 100, 1, 0),
            TestConfig("Ï†ÄÎ∂ÄÌïò", 200, 10, 100),
            TestConfig("Ï§ëÎ∂ÄÌïò", 500, 25, 50),
            TestConfig("Í≥†Î∂ÄÌïò", 1000, 50, 20)
        )

        val overallResult = ResponseTimeResult(endpoint, 0)

        testConfigurations.forEach { config ->
            println("  üìà ${endpoint.name} - ${config.name} ÌÖåÏä§Ìä∏...")
            val result = executeLoadTest(endpoint, config)
            
            // Í≤∞Í≥º ÏßëÍ≥Ñ
            overallResult.successfulRequests.addAndGet(result.successfulRequests.get())
            overallResult.failedRequests.addAndGet(result.failedRequests.get())
            overallResult.totalResponseTime.addAndGet(result.totalResponseTime.get())
            overallResult.minResponseTime.updateAndGet { minOf(it, result.minResponseTime.get()) }
            overallResult.maxResponseTime.updateAndGet { maxOf(it, result.maxResponseTime.get()) }
            
            // ÏùëÎãµÏãúÍ∞Ñ Î∂ÑÌè¨ Î≥ëÌï©
            result.responseTimes.forEach { (time, count) ->
                overallResult.responseTimes.merge(time, count) { old, new -> old + new }
            }
            
            // ÏóêÎü¨ Î©îÏãúÏßÄ Î≥ëÌï©
            result.errorMessages.forEach { (error, count) ->
                overallResult.errorMessages.merge(error, count) { old, new -> 
                    AtomicInteger(old.get() + new.get()) 
                }
            }
        }

        return overallResult.copy(totalRequests = testConfigurations.sumOf { it.requests })
    }

    private data class TestConfig(
        val name: String,
        val requests: Int,
        val concurrency: Int,
        val delayMs: Long
    )

    private suspend fun executeLoadTest(endpoint: ApiEndpoint, config: TestConfig): ResponseTimeResult {
        val result = ResponseTimeResult(endpoint, config.requests)

        // ÎèôÏãú ÏöîÏ≤≠ Ïã§Ìñâ
        val jobs = (1..config.requests).chunked(config.requests / config.concurrency).map { chunk ->
            async(Dispatchers.IO) {
                chunk.forEach { requestIndex ->
                    try {
                        val responseTime = when (endpoint.type) {
                            ApiType.MVC -> executeMvcRequest(endpoint.path, requestIndex)
                            ApiType.WEBFLUX -> executeWebFluxRequest(endpoint.path, requestIndex)
                        }
                        
                        // ÏÑ±Í≥µ Ï≤òÎ¶¨
                        result.successfulRequests.incrementAndGet()
                        result.totalResponseTime.addAndGet(responseTime)
                        result.minResponseTime.updateAndGet { minOf(it, responseTime) }
                        result.maxResponseTime.updateAndGet { maxOf(it, responseTime) }
                        
                        // ÏùëÎãµÏãúÍ∞Ñ Î∂ÑÌè¨ Í∏∞Î°ù (10ms Îã®ÏúÑÎ°ú Í∑∏Î£πÌôî)
                        val timeGroup = (responseTime / 10) * 10
                        result.responseTimes.merge(timeGroup, 1) { old, new -> old + new }
                        
                    } catch (e: Exception) {
                        result.failedRequests.incrementAndGet()
                        val errorType = e.javaClass.simpleName
                        result.errorMessages.computeIfAbsent(errorType) { AtomicInteger(0) }.incrementAndGet()
                    }
                    
                    // ÏöîÏ≤≠ Í∞Ñ ÏßÄÏó∞
                    if (config.delayMs > 0) {
                        delay(Random.nextLong(config.delayMs / 2, config.delayMs))
                    }
                }
            }
        }

        jobs.awaitAll()
        return result
    }

    private suspend fun executeMvcRequest(path: String, requestIndex: Int): Long {
        return measureTimeMillis {
            val request = createTestRequest(requestIndex)
            val headers = HttpHeaders().apply {
                contentType = MediaType.APPLICATION_JSON
            }
            val entity = HttpEntity(request, headers)
            
            restTemplate.postForObject("http://localhost:8080$path", entity, Any::class.java)
        }
    }

    private suspend fun executeWebFluxRequest(path: String, requestIndex: Int): Long {
        return measureTimeMillis {
            val request = createTestRequest(requestIndex)
            
            webClient.post()
                .uri(path)
                .contentType(MediaType.APPLICATION_JSON)
                .bodyValue(request)
                .retrieve()
                .awaitBody<Any>()
        }
    }

    private fun createTestRequest(requestIndex: Int): CreateReservationRequest {
        return CreateReservationRequest(
            guestName = "API Test Guest $requestIndex",
            roomNumber = "Room ${Random.nextInt(1, 101)}",
            checkInDate = "2024-12-${String.format("%02d", Random.nextInt(10, 28))}",
            checkOutDate = "2024-12-${String.format("%02d", Random.nextInt(28, 31))}",
            totalAmount = Random.nextDouble(100.0, 500.0)
        )
    }

    private fun analyzeAndPrintResults(results: List<ResponseTimeResult>) {
        println("\n" + "=" * 80)
        println("üìä API ÏùëÎãµ ÏãúÍ∞Ñ ÎπÑÍµê Î∂ÑÏÑù Í≤∞Í≥º")
        println("=" * 80)
        println("Ïã§Ìñâ ÏãúÍ∞Ñ: ${LocalDateTime.now()}")
        println()

        // Í∞úÎ≥Ñ Í≤∞Í≥º Ï∂úÎ†•
        results.forEach { result ->
            printDetailedResult(result)
        }

        // ÎπÑÍµê Î∂ÑÏÑù
        printComparativeAnalysis(results)
        
        // ÏÑ±Îä• Í∂åÏû•ÏÇ¨Ìï≠
        printRecommendations(results)
    }

    private fun printDetailedResult(result: ResponseTimeResult) {
        val endpoint = result.endpoint
        println("üéØ ${endpoint.name} (${endpoint.type}, ${endpoint.language})")
        println("-" * 60)
        
        println("Í∏∞Î≥∏ ÌÜµÍ≥Ñ:")
        println("  Ï¥ù ÏöîÏ≤≠ Ïàò: ${result.totalRequests}")
        println("  ÏÑ±Í≥µ ÏöîÏ≤≠: ${result.successfulRequests.get()}")
        println("  Ïã§Ìå® ÏöîÏ≤≠: ${result.failedRequests.get()}")
        println("  ÏÑ±Í≥µÎ•†: ${"%.2f".format(result.getSuccessRate())}%")
        
        println("\nÏùëÎãµ ÏãúÍ∞Ñ:")
        println("  ÌèâÍ∑†: ${"%.2f".format(result.getAverageResponseTime())}ms")
        println("  ÏµúÏÜå: ${if (result.minResponseTime.get() == Long.MAX_VALUE) 0 else result.minResponseTime.get()}ms")
        println("  ÏµúÎåÄ: ${result.maxResponseTime.get()}ms")
        
        // Î∞±Î∂ÑÏúÑÏàò Í≥ÑÏÇ∞
        val percentiles = calculatePercentiles(result.responseTimes)
        println("  P50 (Ï§ëÍ∞ÑÍ∞í): ${"%.0f".format(percentiles[50] ?: 0.0)}ms")
        println("  P95: ${"%.0f".format(percentiles[95] ?: 0.0)}ms")
        println("  P99: ${"%.0f".format(percentiles[99] ?: 0.0)}ms")
        
        // ÏùëÎãµÏãúÍ∞Ñ Î∂ÑÌè¨
        println("\nÏùëÎãµÏãúÍ∞Ñ Î∂ÑÌè¨:")
        val sortedDistribution = result.responseTimes.toSortedMap()
        sortedDistribution.forEach { (timeGroup, count) ->
            val percentage = (count.toDouble() / result.successfulRequests.get() * 100)
            if (percentage >= 5.0) { // 5% Ïù¥ÏÉÅÏù∏ Íµ¨Í∞ÑÎßå ÌëúÏãú
                println("  ${timeGroup}ms ~ ${timeGroup + 9}ms: ${count}Ìöå (${"%.1f".format(percentage)}%)")
            }
        }
        
        // ÏóêÎü¨ Î∂ÑÏÑù
        if (result.errorMessages.isNotEmpty()) {
            println("\nÏóêÎü¨ Î∂ÑÏÑù:")
            result.errorMessages.forEach { (error, count) ->
                println("  $error: ${count.get()}Ìöå")
            }
        }
        
        println()
    }

    private fun calculatePercentiles(responseTimes: ConcurrentHashMap<Long, Int>): Map<Int, Double> {
        val sortedTimes = mutableListOf<Long>()
        responseTimes.forEach { (time, count) ->
            repeat(count) { sortedTimes.add(time) }
        }
        sortedTimes.sort()
        
        val percentiles = mutableMapOf<Int, Double>()
        listOf(50, 95, 99).forEach { percentile ->
            if (sortedTimes.isNotEmpty()) {
                val index = ((percentile / 100.0) * (sortedTimes.size - 1)).toInt()
                percentiles[percentile] = sortedTimes[index.coerceIn(0, sortedTimes.size - 1)].toDouble()
            }
        }
        
        return percentiles
    }

    private fun printComparativeAnalysis(results: List<ResponseTimeResult>) {
        println("üîç ÎπÑÍµê Î∂ÑÏÑù")
        println("-" * 60)
        
        // MVC vs WebFlux ÎπÑÍµê
        val mvcResults = results.filter { it.endpoint.type == ApiType.MVC }
        val webFluxResults = results.filter { it.endpoint.type == ApiType.WEBFLUX }
        
        if (mvcResults.isNotEmpty() && webFluxResults.isNotEmpty()) {
            val mvcAvgTime = mvcResults.map { it.getAverageResponseTime() }.average()
            val webFluxAvgTime = webFluxResults.map { it.getAverageResponseTime() }.average()
            val mvcSuccessRate = mvcResults.map { it.getSuccessRate() }.average()
            val webFluxSuccessRate = webFluxResults.map { it.getSuccessRate() }.average()
            
            println("üìà MVC vs WebFlux:")
            println("  ÌèâÍ∑† ÏùëÎãµÏãúÍ∞Ñ - MVC: ${"%.2f".format(mvcAvgTime)}ms, WebFlux: ${"%.2f".format(webFluxAvgTime)}ms")
            println("  ÏÑ±Îä• Ï∞®Ïù¥: ${if (mvcAvgTime > webFluxAvgTime) "WebFluxÍ∞Ä ${"%.1f".format((mvcAvgTime - webFluxAvgTime) / mvcAvgTime * 100)}% Îπ†Î¶Ñ" else "MVCÍ∞Ä ${"%.1f".format((webFluxAvgTime - mvcAvgTime) / webFluxAvgTime * 100)}% Îπ†Î¶Ñ"}")
            println("  ÏÑ±Í≥µÎ•† - MVC: ${"%.2f".format(mvcSuccessRate)}%, WebFlux: ${"%.2f".format(webFluxSuccessRate)}%")
        }
        
        // Java vs Kotlin ÎπÑÍµê
        val kotlinResults = results.filter { it.endpoint.language == Language.KOTLIN }
        val javaResults = results.filter { it.endpoint.language == Language.JAVA }
        
        if (kotlinResults.isNotEmpty() && javaResults.isNotEmpty()) {
            val kotlinAvgTime = kotlinResults.map { it.getAverageResponseTime() }.average()
            val javaAvgTime = javaResults.map { it.getAverageResponseTime() }.average()
            
            println("\nüî§ Kotlin vs Java:")
            println("  ÌèâÍ∑† ÏùëÎãµÏãúÍ∞Ñ - Kotlin: ${"%.2f".format(kotlinAvgTime)}ms, Java: ${"%.2f".format(javaAvgTime)}ms")
            println("  ÏÑ±Îä• Ï∞®Ïù¥: ${if (kotlinAvgTime > javaAvgTime) "JavaÍ∞Ä ${"%.1f".format((kotlinAvgTime - javaAvgTime) / kotlinAvgTime * 100)}% Îπ†Î¶Ñ" else "KotlinÏù¥ ${"%.1f".format((javaAvgTime - kotlinAvgTime) / javaAvgTime * 100)}% Îπ†Î¶Ñ"}")
        }
        
        // Ï†ÑÏ≤¥ ÏàúÏúÑ
        println("\nüèÜ Ï†ÑÏ≤¥ ÏÑ±Îä• ÏàúÏúÑ (ÌèâÍ∑† ÏùëÎãµÏãúÍ∞Ñ Í∏∞Ï§Ä):")
        results.sortedBy { it.getAverageResponseTime() }.forEachIndexed { index, result ->
            println("  ${index + 1}ÏúÑ: ${result.endpoint.name} - ${"%.2f".format(result.getAverageResponseTime())}ms")
        }
        
        println()
    }

    private fun printRecommendations(results: List<ResponseTimeResult>) {
        println("üí° ÏÑ±Îä• ÏµúÏ†ÅÌôî Í∂åÏû•ÏÇ¨Ìï≠")
        println("-" * 60)
        
        results.forEach { result ->
            val avgTime = result.getAverageResponseTime()
            val successRate = result.getSuccessRate()
            
            println("${result.endpoint.name}:")
            
            when {
                avgTime > 200 -> println("  ‚ö†Ô∏è ÎÜíÏùÄ ÏùëÎãµÏãúÍ∞Ñ: Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ ÏøºÎ¶¨ ÏµúÏ†ÅÌôî ÎòêÎäî Ï∫êÏã± Ï†ÅÏö© Í∂åÏû•")
                avgTime > 100 -> println("  üìä Î≥¥ÌÜµ ÏùëÎãµÏãúÍ∞Ñ: Ïù∏Îç±Ïä§ ÏµúÏ†ÅÌôî Í≤ÄÌÜ† Í∂åÏû•")
                else -> println("  ‚úÖ Ïö∞ÏàòÌïú ÏùëÎãµÏãúÍ∞Ñ")
            }
            
            when {
                successRate < 95 -> println("  ‚ùå ÎÇÆÏùÄ ÏÑ±Í≥µÎ•†: ÏóêÎü¨ Ï≤òÎ¶¨ Î°úÏßÅ Î∞è ÌÉÄÏûÑÏïÑÏõÉ ÏÑ§Ï†ï Í≤ÄÌÜ† ÌïÑÏöî")
                successRate < 99 -> println("  ‚ö†Ô∏è Î≥¥ÌÜµ ÏÑ±Í≥µÎ•†: ÏòàÏô∏ Ï≤òÎ¶¨ Í∞úÏÑ† Í∂åÏû•")
                else -> println("  ‚úÖ Ïö∞ÏàòÌïú ÏïàÏ†ïÏÑ±")
            }
            
            // ÌäπÏ†ï Í∏∞Ïà†Î≥Ñ Í∂åÏû•ÏÇ¨Ìï≠
            when (result.endpoint.type) {
                ApiType.MVC -> {
                    if (avgTime > 150) {
                        println("  üí° MVC ÏµúÏ†ÅÌôî: Ïä§Î†àÎìú ÌíÄ ÌÅ¨Í∏∞ Ï°∞Ï†ï, Ïó∞Í≤∞ ÌíÄ ÏµúÏ†ÅÌôî Í≥†Î†§")
                    }
                }
                ApiType.WEBFLUX -> {
                    if (avgTime > 150) {
                        println("  üí° WebFlux ÏµúÏ†ÅÌôî: Î∞±ÌîÑÎ†àÏÖî Ï≤òÎ¶¨, ÎÖºÎ∏îÎ°úÌÇπ I/O ÌôúÏö© Í≤ÄÌÜ†")
                    }
                }
            }
            
            println()
        }
        
        println("üéØ Ï†ÑÎ∞òÏ†Å Í∂åÏû•ÏÇ¨Ìï≠:")
        println("- ÏßÄÏÜçÏ†ÅÏù∏ Î™®ÎãàÌÑ∞ÎßÅÏùÑ ÌÜµÌïú ÏÑ±Îä• Ï∂îÏù¥ Í¥ÄÏ∞∞")
        println("- ÌîÑÎ°úÎçïÏÖò ÌôòÍ≤ΩÏóêÏÑúÏùò Ïã§Ï†ú Î∂ÄÌïò ÌÖåÏä§Ìä∏ ÏàòÌñâ")
        println("- APM ÎèÑÍµ¨ Ïó∞ÎèôÏúºÎ°ú ÏÉÅÏÑ∏Ìïú ÏÑ±Îä• Î∂ÑÏÑù")
        println("- Ï∫êÏãú Ï†ÑÎûµ Î∞è Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ ÏµúÏ†ÅÌôî Ï†ÅÏö©")
        
        println("\n" + "=" * 80)
    }
}