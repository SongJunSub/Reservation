package com.example.reservation.benchmark

import com.example.reservation.entity.User
import com.example.reservation.repository.UserRepository
import io.jsonwebtoken.Jwts
import io.jsonwebtoken.SignatureAlgorithm
import io.jsonwebtoken.security.Keys
import kotlinx.coroutines.*
import org.springframework.beans.factory.annotation.Autowired
import org.springframework.beans.factory.annotation.Value
import org.springframework.boot.CommandLineRunner
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder
import org.springframework.security.crypto.password.PasswordEncoder
import org.springframework.stereotype.Component
import java.nio.charset.StandardCharsets
import java.security.MessageDigest
import java.security.SecureRandom
import java.time.LocalDateTime
import java.time.format.DateTimeFormatter
import java.util.*
import java.util.concurrent.atomic.AtomicLong
import javax.crypto.Cipher
import javax.crypto.KeyGenerator
import javax.crypto.spec.GCMParameterSpec
import javax.crypto.spec.SecretKeySpec
import kotlin.system.measureTimeMillis

data class SecurityMetrics(
    val timestamp: LocalDateTime = LocalDateTime.now(),
    val operationType: String,
    val algorithm: String,
    val keySize: Int = 0,
    val dataSize: Int,
    val operationTime: Long,
    val throughput: Double,
    val memoryUsed: Long = 0,
    val cpuIntensive: Boolean = false,
    val errorCount: Long = 0,
    val successCount: Long = 0
)

data class JWTPerformanceResult(
    val tokenGeneration: SecurityMetrics,
    val tokenValidation: SecurityMetrics,
    val tokenParsing: SecurityMetrics,
    val overallThroughput: Double,
    val memoryFootprint: Long,
    val recommendations: List<String>
)

data class CryptoPerformanceResult(
    val encryptionMetrics: SecurityMetrics,
    val decryptionMetrics: SecurityMetrics,
    val hashingMetrics: SecurityMetrics,
    val passwordMetrics: SecurityMetrics,
    val overallScore: Double,
    val recommendations: List<String>
)

data class ProtocolPerformanceResult(
    val httpMetrics: SecurityMetrics,
    val httpsMetrics: SecurityMetrics,
    val performanceDifference: Double,
    val securityOverhead: Double,
    val recommendations: List<String>
)

data class RateLimitingResult(
    val rateLimitOverhead: SecurityMetrics,
    val throughputImpact: Double,
    val memoryImpact: Long,
    val latencyIncrease: Double,
    val recommendations: List<String>
)

@Component
class SecurityPerformanceAnalyzer(
    @Autowired private val userRepository: UserRepository
) : CommandLineRunner {

    @Value("\${jwt.secret:defaultSecretKeyForTesting123456789}")
    private lateinit var jwtSecret: String

    private val passwordEncoder: PasswordEncoder = BCryptPasswordEncoder()
    private val secureRandom = SecureRandom()
    
    private val performanceLog = mutableListOf<SecurityMetrics>()
    private val requestCounter = AtomicLong(0)
    
    override fun run(vararg args: String?) {
        println("üîê ÏãúÏûë: Security Performance Overhead Analysis")
        println("=" * 80)
        
        runBlocking {
            when (args.getOrNull(0)) {
                "jwt" -> analyzeJWTPerformance()
                "crypto" -> analyzeCryptoPerformance()
                "protocol" -> analyzeProtocolPerformance()
                "ratelimit" -> analyzeRateLimitingImpact()
                "filter-chain" -> analyzeSecurityFilterChain()
                "comprehensive" -> runComprehensiveAnalysis()
                else -> runComprehensiveAnalysis()
            }
        }
        
        generatePerformanceReport()
    }
    
    // ============================================================
    // JWT ÌÜ†ÌÅ∞ Ï≤òÎ¶¨ ÏÑ±Îä• Î∂ÑÏÑù
    // ============================================================
    
    suspend fun analyzeJWTPerformance(): JWTPerformanceResult {
        println("\nüìä Phase 1: JWT Token Processing Performance Analysis")
        println("-".repeat(60))
        
        val secretKey = Keys.hmacShaKeyFor(jwtSecret.toByteArray())
        val sampleClaims = mapOf(
            "sub" to "user123",
            "name" to "Test User",
            "email" to "test@example.com",
            "roles" to listOf("USER", "ADMIN"),
            "exp" to Date(System.currentTimeMillis() + 3600000)
        )
        
        // JWT ÌÜ†ÌÅ∞ ÏÉùÏÑ± ÏÑ±Îä• Ï∏°Ï†ï
        val tokenGenerationMetrics = measureJWTGeneration(secretKey, sampleClaims)
        
        // JWT ÌÜ†ÌÅ∞ Í≤ÄÏ¶ù ÏÑ±Îä• Ï∏°Ï†ï
        val generatedToken = Jwts.builder()
            .setClaims(sampleClaims)
            .setIssuedAt(Date())
            .setExpiration(Date(System.currentTimeMillis() + 3600000))
            .signWith(secretKey, SignatureAlgorithm.HS256)
            .compact()
            
        val tokenValidationMetrics = measureJWTValidation(secretKey, generatedToken)
        
        // JWT ÌÜ†ÌÅ∞ ÌååÏã± ÏÑ±Îä• Ï∏°Ï†ï
        val tokenParsingMetrics = measureJWTParsing(secretKey, generatedToken)
        
        val overallThroughput = calculateOverallThroughput(
            listOf(tokenGenerationMetrics, tokenValidationMetrics, tokenParsingMetrics)
        )
        
        val result = JWTPerformanceResult(
            tokenGeneration = tokenGenerationMetrics,
            tokenValidation = tokenValidationMetrics,
            tokenParsing = tokenParsingMetrics,
            overallThroughput = overallThroughput,
            memoryFootprint = measureJWTMemoryFootprint(),
            recommendations = generateJWTRecommendations(tokenGenerationMetrics, tokenValidationMetrics)
        )
        
        printJWTAnalysisResults(result)
        return result
    }
    
    private suspend fun measureJWTGeneration(secretKey: javax.crypto.SecretKey, claims: Map<String, Any>): SecurityMetrics {
        val iterations = 10000
        val dataSize = claims.toString().toByteArray().size
        var successCount = 0L
        var errorCount = 0L
        
        val totalTime = measureTimeMillis {
            repeat(iterations) {
                try {
                    Jwts.builder()
                        .setClaims(claims)
                        .setIssuedAt(Date())
                        .setExpiration(Date(System.currentTimeMillis() + 3600000))
                        .signWith(secretKey, SignatureAlgorithm.HS256)
                        .compact()
                    successCount++
                } catch (e: Exception) {
                    errorCount++
                }
            }
        }
        
        return SecurityMetrics(
            operationType = "JWT_GENERATION",
            algorithm = "HS256",
            keySize = 256,
            dataSize = dataSize,
            operationTime = totalTime,
            throughput = (iterations.toDouble() / totalTime) * 1000,
            cpuIntensive = true,
            successCount = successCount,
            errorCount = errorCount
        )
    }
    
    private suspend fun measureJWTValidation(secretKey: javax.crypto.SecretKey, token: String): SecurityMetrics {
        val iterations = 10000
        val dataSize = token.toByteArray().size
        var successCount = 0L
        var errorCount = 0L
        
        val totalTime = measureTimeMillis {
            repeat(iterations) {
                try {
                    Jwts.parserBuilder()
                        .setSigningKey(secretKey)
                        .build()
                        .parseClaimsJws(token)
                    successCount++
                } catch (e: Exception) {
                    errorCount++
                }
            }
        }
        
        return SecurityMetrics(
            operationType = "JWT_VALIDATION",
            algorithm = "HS256",
            keySize = 256,
            dataSize = dataSize,
            operationTime = totalTime,
            throughput = (iterations.toDouble() / totalTime) * 1000,
            cpuIntensive = true,
            successCount = successCount,
            errorCount = errorCount
        )
    }
    
    private suspend fun measureJWTParsing(secretKey: javax.crypto.SecretKey, token: String): SecurityMetrics {
        val iterations = 10000
        val dataSize = token.toByteArray().size
        var successCount = 0L
        var errorCount = 0L
        
        val totalTime = measureTimeMillis {
            repeat(iterations) {
                try {
                    val claims = Jwts.parserBuilder()
                        .setSigningKey(secretKey)
                        .build()
                        .parseClaimsJws(token)
                        .body
                    
                    // ÌÅ¥Î†àÏûÑ Îç∞Ïù¥ÌÑ∞Ïóê Ï†ëÍ∑ºÌïòÏó¨ Ïã§Ï†ú ÌååÏã± ÏûëÏóÖ ÏàòÌñâ
                    claims["sub"]
                    claims["name"]
                    claims["email"]
                    claims["roles"]
                    
                    successCount++
                } catch (e: Exception) {
                    errorCount++
                }
            }
        }
        
        return SecurityMetrics(
            operationType = "JWT_PARSING",
            algorithm = "HS256",
            keySize = 256,
            dataSize = dataSize,
            operationTime = totalTime,
            throughput = (iterations.toDouble() / totalTime) * 1000,
            cpuIntensive = false,
            successCount = successCount,
            errorCount = errorCount
        )
    }
    
    // ============================================================
    // ÏïîÌò∏Ìôî/Î≥µÌò∏Ìôî Ïò§Î≤ÑÌó§Îìú Ï∏°Ï†ï
    // ============================================================
    
    suspend fun analyzeCryptoPerformance(): CryptoPerformanceResult {
        println("\nüîí Phase 2: Encryption/Decryption Overhead Analysis")
        println("-".repeat(60))
        
        val testData = "This is a test message for encryption performance analysis. ".repeat(100)
        
        // AES ÏïîÌò∏Ìôî/Î≥µÌò∏Ìôî ÏÑ±Îä• Ï∏°Ï†ï
        val aesMetrics = measureAESPerformance(testData)
        
        // Ìï¥Ïã± ÏïåÍ≥†Î¶¨Ï¶ò ÏÑ±Îä• Ï∏°Ï†ï
        val hashingMetrics = measureHashingPerformance(testData)
        
        // Ìå®Ïä§ÏõåÎìú Ïù∏ÏΩîÎî© ÏÑ±Îä• Ï∏°Ï†ï
        val passwordMetrics = measurePasswordEncodingPerformance()
        
        val overallScore = calculateCryptoScore(aesMetrics.first, aesMetrics.second, hashingMetrics, passwordMetrics)
        
        val result = CryptoPerformanceResult(
            encryptionMetrics = aesMetrics.first,
            decryptionMetrics = aesMetrics.second,
            hashingMetrics = hashingMetrics,
            passwordMetrics = passwordMetrics,
            overallScore = overallScore,
            recommendations = generateCryptoRecommendations(aesMetrics.first, hashingMetrics, passwordMetrics)
        )
        
        printCryptoAnalysisResults(result)
        return result
    }
    
    private suspend fun measureAESPerformance(data: String): Pair<SecurityMetrics, SecurityMetrics> {
        val keyGen = KeyGenerator.getInstance("AES")
        keyGen.init(256)
        val secretKey = keyGen.generateKey()
        
        val cipher = Cipher.getInstance("AES/GCM/NoPadding")
        val dataBytes = data.toByteArray(StandardCharsets.UTF_8)
        val iterations = 1000
        
        // ÏïîÌò∏Ìôî ÏÑ±Îä• Ï∏°Ï†ï
        var encryptedData: ByteArray = byteArrayOf()
        var iv: ByteArray = byteArrayOf()
        val encryptionTime = measureTimeMillis {
            repeat(iterations) {
                cipher.init(Cipher.ENCRYPT_MODE, secretKey)
                iv = cipher.iv
                encryptedData = cipher.doFinal(dataBytes)
            }
        }
        
        val encryptionMetrics = SecurityMetrics(
            operationType = "AES_ENCRYPTION",
            algorithm = "AES-256-GCM",
            keySize = 256,
            dataSize = dataBytes.size,
            operationTime = encryptionTime,
            throughput = (iterations.toDouble() / encryptionTime) * 1000,
            cpuIntensive = true,
            successCount = iterations.toLong()
        )
        
        // Î≥µÌò∏Ìôî ÏÑ±Îä• Ï∏°Ï†ï
        val decryptionTime = measureTimeMillis {
            repeat(iterations) {
                val gcmSpec = GCMParameterSpec(128, iv)
                cipher.init(Cipher.DECRYPT_MODE, secretKey, gcmSpec)
                cipher.doFinal(encryptedData)
            }
        }
        
        val decryptionMetrics = SecurityMetrics(
            operationType = "AES_DECRYPTION",
            algorithm = "AES-256-GCM",
            keySize = 256,
            dataSize = encryptedData.size,
            operationTime = decryptionTime,
            throughput = (iterations.toDouble() / decryptionTime) * 1000,
            cpuIntensive = true,
            successCount = iterations.toLong()
        )
        
        return Pair(encryptionMetrics, decryptionMetrics)
    }
    
    private suspend fun measureHashingPerformance(data: String): SecurityMetrics {
        val algorithms = listOf("SHA-256", "SHA-512", "MD5")
        val iterations = 10000
        val dataBytes = data.toByteArray(StandardCharsets.UTF_8)
        
        var bestAlgorithm = ""
        var bestThroughput = 0.0
        var totalTime = 0L
        
        algorithms.forEach { algorithm ->
            val time = measureTimeMillis {
                repeat(iterations) {
                    MessageDigest.getInstance(algorithm).digest(dataBytes)
                }
            }
            
            val throughput = (iterations.toDouble() / time) * 1000
            if (throughput > bestThroughput) {
                bestThroughput = throughput
                bestAlgorithm = algorithm
                totalTime = time
            }
        }
        
        return SecurityMetrics(
            operationType = "HASHING",
            algorithm = bestAlgorithm,
            dataSize = dataBytes.size,
            operationTime = totalTime,
            throughput = bestThroughput,
            cpuIntensive = true,
            successCount = iterations.toLong()
        )
    }
    
    private suspend fun measurePasswordEncodingPerformance(): SecurityMetrics {
        val passwords = listOf(
            "password123",
            "strongPassword!@#",
            "verylongpasswordwithmanycharacters123456789"
        )
        
        val iterations = 100 // BCryptÎäî ÏùòÎèÑÏ†ÅÏúºÎ°ú ÎäêÎ¶¨ÎØÄÎ°ú Ï†ÅÏùÄ Î∞òÎ≥µ
        var totalTime = 0L
        var successCount = 0L
        
        passwords.forEach { password ->
            val time = measureTimeMillis {
                repeat(iterations) {
                    try {
                        val encoded = passwordEncoder.encode(password)
                        passwordEncoder.matches(password, encoded)
                        successCount++
                    } catch (e: Exception) {
                        // Ïò§Î•ò Ï≤òÎ¶¨
                    }
                }
            }
            totalTime += time
        }
        
        return SecurityMetrics(
            operationType = "PASSWORD_ENCODING",
            algorithm = "BCrypt",
            dataSize = passwords.sumOf { it.length },
            operationTime = totalTime,
            throughput = (successCount.toDouble() / totalTime) * 1000,
            cpuIntensive = true,
            successCount = successCount
        )
    }
    
    // ============================================================
    // HTTPS vs HTTP ÏÑ±Îä• ÎπÑÍµê
    // ============================================================
    
    suspend fun analyzeProtocolPerformance(): ProtocolPerformanceResult {
        println("\nüåê Phase 3: HTTPS vs HTTP Performance Analysis")
        println("-".repeat(60))
        
        // HTTP ÏãúÎÆ¨Î†àÏù¥ÏÖò (SSL Ïò§Î≤ÑÌó§Îìú ÏóÜÏùå)
        val httpMetrics = simulateHTTPPerformance()
        
        // HTTPS ÏãúÎÆ¨Î†àÏù¥ÏÖò (SSL Ìï∏ÎìúÏÖ∞Ïù¥ÌÅ¨ + ÏïîÌò∏Ìôî Ïò§Î≤ÑÌó§Îìú)
        val httpsMetrics = simulateHTTPSPerformance()
        
        val performanceDifference = ((httpsMetrics.operationTime - httpMetrics.operationTime).toDouble() / httpMetrics.operationTime) * 100
        val securityOverhead = httpsMetrics.operationTime - httpMetrics.operationTime
        
        val result = ProtocolPerformanceResult(
            httpMetrics = httpMetrics,
            httpsMetrics = httpsMetrics,
            performanceDifference = performanceDifference,
            securityOverhead = securityOverhead.toDouble(),
            recommendations = generateProtocolRecommendations(performanceDifference)
        )
        
        printProtocolAnalysisResults(result)
        return result
    }
    
    private suspend fun simulateHTTPPerformance(): SecurityMetrics {
        val iterations = 10000
        val requestSize = 1024 // 1KB ÏöîÏ≤≠ ÏãúÎÆ¨Î†àÏù¥ÏÖò
        
        val totalTime = measureTimeMillis {
            repeat(iterations) {
                // HTTP ÏöîÏ≤≠ ÏãúÎÆ¨Î†àÏù¥ÏÖò (ÎÑ§Ìä∏ÏõåÌÅ¨ ÏßÄÏó∞ ÏãúÎÆ¨Î†àÏù¥ÏÖò)
                delay(1) // 1ms Í∏∞Î≥∏ ÎÑ§Ìä∏ÏõåÌÅ¨ ÏßÄÏó∞
                
                // Îã®Ïàú Îç∞Ïù¥ÌÑ∞ Ï†ÑÏÜ° ÏãúÎÆ¨Î†àÏù¥ÏÖò
                val data = ByteArray(requestSize)
                secureRandom.nextBytes(data)
            }
        }
        
        return SecurityMetrics(
            operationType = "HTTP_REQUEST",
            algorithm = "None",
            dataSize = requestSize,
            operationTime = totalTime,
            throughput = (iterations.toDouble() / totalTime) * 1000,
            cpuIntensive = false,
            successCount = iterations.toLong()
        )
    }
    
    private suspend fun simulateHTTPSPerformance(): SecurityMetrics {
        val iterations = 10000
        val requestSize = 1024 // 1KB ÏöîÏ≤≠ ÏãúÎÆ¨Î†àÏù¥ÏÖò
        
        val totalTime = measureTimeMillis {
            repeat(iterations) {
                // HTTPS Ïò§Î≤ÑÌó§Îìú ÏãúÎÆ¨Î†àÏù¥ÏÖò
                delay(1) // Í∏∞Î≥∏ ÎÑ§Ìä∏ÏõåÌÅ¨ ÏßÄÏó∞
                
                // SSL Ìï∏ÎìúÏÖ∞Ïù¥ÌÅ¨ ÏãúÎÆ¨Î†àÏù¥ÏÖò (Ï≤´ Ïó∞Í≤∞ÏãúÏóêÎßå Î∞úÏÉùÌïòÏßÄÎßå Ïó¨Í∏∞ÏÑúÎäî ÏãúÎÆ¨Î†àÏù¥ÏÖò)
                if (it % 100 == 0) { // 100Í∞ú ÏöîÏ≤≠ÎßàÎã§ ÏÉà Ïó∞Í≤∞ Í∞ÄÏ†ï
                    delay(10) // SSL Ìï∏ÎìúÏÖ∞Ïù¥ÌÅ¨ Ï∂îÍ∞Ä ÏßÄÏó∞
                }
                
                // Îç∞Ïù¥ÌÑ∞ ÏïîÌò∏Ìôî ÏãúÎÆ¨Î†àÏù¥ÏÖò
                val data = ByteArray(requestSize)
                secureRandom.nextBytes(data)
                
                // AES ÏïîÌò∏Ìôî ÏãúÎÆ¨Î†àÏù¥ÏÖò
                val cipher = Cipher.getInstance("AES/GCM/NoPadding")
                val keyGen = KeyGenerator.getInstance("AES")
                keyGen.init(256)
                val key = keyGen.generateKey()
                cipher.init(Cipher.ENCRYPT_MODE, key)
                cipher.doFinal(data)
            }
        }
        
        return SecurityMetrics(
            operationType = "HTTPS_REQUEST",
            algorithm = "TLS-1.3-AES-256",
            keySize = 256,
            dataSize = requestSize,
            operationTime = totalTime,
            throughput = (iterations.toDouble() / totalTime) * 1000,
            cpuIntensive = true,
            successCount = iterations.toLong()
        )
    }
    
    // ============================================================
    // Rate Limiting ÏÑ±Îä• ÏòÅÌñ• Î∂ÑÏÑù
    // ============================================================
    
    suspend fun analyzeRateLimitingImpact(): RateLimitingResult {
        println("\n‚è±Ô∏è Phase 4: Rate Limiting Performance Impact Analysis")
        println("-".repeat(60))
        
        // Rate Limiting ÏóÜÎäî Í≤ΩÏö∞ÏôÄ ÏûàÎäî Í≤ΩÏö∞ ÎπÑÍµê
        val withoutRateLimitMetrics = measurePerformanceWithoutRateLimit()
        val withRateLimitMetrics = measurePerformanceWithRateLimit()
        
        val throughputImpact = ((withoutRateLimitMetrics.throughput - withRateLimitMetrics.throughput) / withoutRateLimitMetrics.throughput) * 100
        val memoryImpact = estimateRateLimitMemoryUsage()
        val latencyIncrease = withRateLimitMetrics.operationTime.toDouble() - withoutRateLimitMetrics.operationTime
        
        val result = RateLimitingResult(
            rateLimitOverhead = withRateLimitMetrics,
            throughputImpact = throughputImpact,
            memoryImpact = memoryImpact,
            latencyIncrease = latencyIncrease,
            recommendations = generateRateLimitRecommendations(throughputImpact, memoryImpact)
        )
        
        printRateLimitAnalysisResults(result)
        return result
    }
    
    private suspend fun measurePerformanceWithoutRateLimit(): SecurityMetrics {
        val iterations = 10000
        val requestSize = 512
        
        val totalTime = measureTimeMillis {
            repeat(iterations) {
                // Í∏∞Î≥∏ ÏöîÏ≤≠ Ï≤òÎ¶¨ ÏãúÎÆ¨Î†àÏù¥ÏÖò
                processRequest(requestSize)
            }
        }
        
        return SecurityMetrics(
            operationType = "NO_RATE_LIMIT",
            algorithm = "None",
            dataSize = requestSize,
            operationTime = totalTime,
            throughput = (iterations.toDouble() / totalTime) * 1000,
            successCount = iterations.toLong()
        )
    }
    
    private suspend fun measurePerformanceWithRateLimit(): SecurityMetrics {
        val iterations = 10000
        val requestSize = 512
        val rateLimitMap = mutableMapOf<String, MutableList<Long>>()
        val rateLimit = 100 // Ï¥àÎãπ 100 ÏöîÏ≤≠
        var blockedRequests = 0L
        var successfulRequests = 0L
        
        val totalTime = measureTimeMillis {
            repeat(iterations) {
                val clientId = "client_${it % 10}" // 10Í∞ú ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏ ÏãúÎÆ¨Î†àÏù¥ÏÖò
                val currentTime = System.currentTimeMillis()
                
                // Rate Limiting Ï≤¥ÌÅ¨
                val clientRequests = rateLimitMap.getOrPut(clientId) { mutableListOf() }
                
                // 1Ï¥à Ïù¥Ï†Ñ ÏöîÏ≤≠Îì§ Ï†úÍ±∞
                clientRequests.removeAll { it < currentTime - 1000 }
                
                if (clientRequests.size < rateLimit) {
                    clientRequests.add(currentTime)
                    processRequest(requestSize)
                    successfulRequests++
                } else {
                    // Rate limit Ï¥àÍ≥º
                    blockedRequests++
                    delay(1) // Í±∞Î∂Ä Ï≤òÎ¶¨ ÏãúÍ∞Ñ
                }
            }
        }
        
        return SecurityMetrics(
            operationType = "WITH_RATE_LIMIT",
            algorithm = "Token_Bucket",
            dataSize = requestSize,
            operationTime = totalTime,
            throughput = (successfulRequests.toDouble() / totalTime) * 1000,
            successCount = successfulRequests,
            errorCount = blockedRequests
        )
    }
    
    private suspend fun processRequest(size: Int) {
        // ÏöîÏ≤≠ Ï≤òÎ¶¨ ÏãúÎÆ¨Î†àÏù¥ÏÖò
        delay(1)
        val data = ByteArray(size)
        secureRandom.nextBytes(data)
    }
    
    // ============================================================
    // Î≥¥Ïïà ÌïÑÌÑ∞ Ï≤¥Ïù∏ ÏµúÏ†ÅÌôî Î∂ÑÏÑù
    // ============================================================
    
    suspend fun analyzeSecurityFilterChain() {
        println("\nüîó Phase 5: Security Filter Chain Optimization Analysis")
        println("-".repeat(60))
        
        val filterChainConfigurations = listOf(
            "Basic" to listOf("CORS", "CSRF", "Authentication"),
            "Enhanced" to listOf("CORS", "CSRF", "Authentication", "Authorization", "RateLimit"),
            "Full" to listOf("CORS", "CSRF", "Authentication", "Authorization", "RateLimit", "XSS", "ContentType", "HSTS")
        )
        
        filterChainConfigurations.forEach { (name, filters) ->
            val metrics = measureFilterChainPerformance(name, filters)
            performanceLog.add(metrics)
            
            println("üìã Filter Chain: $name")
            println("   Filters: ${filters.joinToString(", ")}")
            println("   Processing Time: ${metrics.operationTime}ms")
            println("   Throughput: ${"%.2f".format(metrics.throughput)} req/sec")
            println("   Memory Overhead: ${estimateFilterMemoryUsage(filters)}KB")
            println()
        }
        
        generateFilterChainRecommendations()
    }
    
    private suspend fun measureFilterChainPerformance(name: String, filters: List<String>): SecurityMetrics {
        val iterations = 1000
        val requestSize = 1024
        
        val totalTime = measureTimeMillis {
            repeat(iterations) {
                filters.forEach { filter ->
                    when (filter) {
                        "CORS" -> delay(1)
                        "CSRF" -> delay(2)
                        "Authentication" -> delay(5)
                        "Authorization" -> delay(3)
                        "RateLimit" -> delay(2)
                        "XSS" -> delay(1)
                        "ContentType" -> delay(1)
                        "HSTS" -> delay(1)
                    }
                }
                processRequest(requestSize)
            }
        }
        
        return SecurityMetrics(
            operationType = "FILTER_CHAIN_$name",
            algorithm = "Multi_Filter",
            dataSize = requestSize,
            operationTime = totalTime,
            throughput = (iterations.toDouble() / totalTime) * 1000,
            memoryUsed = estimateFilterMemoryUsage(filters),
            successCount = iterations.toLong()
        )
    }
    
    // ============================================================
    // Ï¢ÖÌï© ÏÑ±Îä• Î∂ÑÏÑù
    // ============================================================
    
    suspend fun runComprehensiveAnalysis() {
        println("üîç Running Comprehensive Security Performance Analysis")
        println("=" * 80)
        
        val jwtResult = analyzeJWTPerformance()
        val cryptoResult = analyzeCryptoPerformance()
        val protocolResult = analyzeProtocolPerformance()
        val rateLimitResult = analyzeRateLimitingImpact()
        
        analyzeSecurityFilterChain()
        
        println("\nüìà COMPREHENSIVE ANALYSIS SUMMARY")
        println("=" * 80)
        
        val overallScore = calculateOverallSecurityScore(jwtResult, cryptoResult, protocolResult, rateLimitResult)
        
        println("Overall Security Performance Score: ${"%.2f".format(overallScore)}/100")
        println()
        
        generateComprehensiveRecommendations(jwtResult, cryptoResult, protocolResult, rateLimitResult)
    }
    
    // ============================================================
    // Ïú†Ìã∏Î¶¨Ìã∞ Î©îÏÑúÎìúÎì§
    // ============================================================
    
    private fun calculateOverallThroughput(metrics: List<SecurityMetrics>): Double {
        return metrics.map { it.throughput }.average()
    }
    
    private fun measureJWTMemoryFootprint(): Long {
        val runtime = Runtime.getRuntime()
        val beforeMemory = runtime.totalMemory() - runtime.freeMemory()
        
        // JWT ÌÜ†ÌÅ∞ 1000Í∞ú ÏÉùÏÑ±
        val secretKey = Keys.hmacShaKeyFor(jwtSecret.toByteArray())
        val tokens = mutableListOf<String>()
        
        repeat(1000) {
            val token = Jwts.builder()
                .setSubject("user$it")
                .setIssuedAt(Date())
                .setExpiration(Date(System.currentTimeMillis() + 3600000))
                .signWith(secretKey, SignatureAlgorithm.HS256)
                .compact()
            tokens.add(token)
        }
        
        val afterMemory = runtime.totalMemory() - runtime.freeMemory()
        return afterMemory - beforeMemory
    }
    
    private fun calculateCryptoScore(encryption: SecurityMetrics, decryption: SecurityMetrics, 
                                   hashing: SecurityMetrics, password: SecurityMetrics): Double {
        val encryptionScore = minOf(encryption.throughput / 1000 * 25, 25.0)
        val decryptionScore = minOf(decryption.throughput / 1000 * 25, 25.0)
        val hashingScore = minOf(hashing.throughput / 10000 * 25, 25.0)
        val passwordScore = minOf(password.throughput / 10 * 25, 25.0)
        
        return encryptionScore + decryptionScore + hashingScore + passwordScore
    }
    
    private fun estimateRateLimitMemoryUsage(): Long {
        // Rate LimitingÏùÑ ÏúÑÌïú Î©îÎ™®Î¶¨ ÏÇ¨Ïö©Îüâ Ï∂îÏ†ï (KB)
        val clientCount = 10000 // ÏòàÏÉÅ ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏ Ïàò
        val memoryPerClient = 256 // ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏Îãπ Î©îÎ™®Î¶¨ ÏÇ¨Ïö©Îüâ (bytes)
        return (clientCount * memoryPerClient) / 1024 // KBÎ°ú Î≥ÄÌôò
    }
    
    private fun estimateFilterMemoryUsage(filters: List<String>): Long {
        return filters.size * 64L // ÌïÑÌÑ∞Îãπ 64KB Ï∂îÏ†ï
    }
    
    private fun calculateOverallSecurityScore(jwt: JWTPerformanceResult, crypto: CryptoPerformanceResult,
                                            protocol: ProtocolPerformanceResult, rateLimit: RateLimitingResult): Double {
        val jwtScore = minOf(jwt.overallThroughput / 1000 * 25, 25.0)
        val cryptoScore = crypto.overallScore * 0.25
        val protocolScore = maxOf(25 - (protocol.performanceDifference * 0.5), 0.0)
        val rateLimitScore = maxOf(25 - (rateLimit.throughputImpact * 0.5), 0.0)
        
        return jwtScore + cryptoScore + protocolScore + rateLimitScore
    }
    
    // ============================================================
    // Ï∂îÏ≤úÏÇ¨Ìï≠ ÏÉùÏÑ± Î©îÏÑúÎìúÎì§
    // ============================================================
    
    private fun generateJWTRecommendations(generation: SecurityMetrics, validation: SecurityMetrics): List<String> {
        val recommendations = mutableListOf<String>()
        
        if (generation.throughput < 500) {
            recommendations.add("JWT ÌÜ†ÌÅ∞ ÏÉùÏÑ± ÏÑ±Îä•Ïù¥ ÎÇÆÏäµÎãàÎã§. ÎπÑÎèôÍ∏∞ Ï≤òÎ¶¨ÎÇò ÌÜ†ÌÅ∞ Ï∫êÏã±ÏùÑ Í≥†Î†§ÌïòÏÑ∏Ïöî.")
        }
        
        if (validation.throughput < 1000) {
            recommendations.add("JWT Í≤ÄÏ¶ù ÏÑ±Îä• Í∞úÏÑ†ÏùÑ ÏúÑÌï¥ Í≥µÍ∞úÌÇ§ Ï∫êÏã±ÏùÑ Íµ¨ÌòÑÌïòÏÑ∏Ïöî.")
        }
        
        if (generation.errorCount > 0 || validation.errorCount > 0) {
            recommendations.add("JWT Ï≤òÎ¶¨ Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§. ÌÇ§ Í¥ÄÎ¶¨ÏôÄ ÌÜ†ÌÅ∞ ÌòïÏãùÏùÑ Í≤ÄÌÜ†ÌïòÏÑ∏Ïöî.")
        }
        
        recommendations.add("JWT ÌÜ†ÌÅ∞ ÎßåÎ£å ÏãúÍ∞ÑÏùÑ Ï†ÅÏ†àÌûà ÏÑ§Ï†ïÌïòÏó¨ Î≥¥ÏïàÍ≥º ÏÑ±Îä•Ïùò Í∑†ÌòïÏùÑ ÎßûÏ∂îÏÑ∏Ïöî.")
        recommendations.add("RS256 ÎåÄÏã† HS256 ÏÇ¨Ïö©ÏùÑ Í≥†Î†§ÌïòÏó¨ ÏÑ±Îä•ÏùÑ Í∞úÏÑ†Ìï† Ïàò ÏûàÏäµÎãàÎã§.")
        
        return recommendations
    }
    
    private fun generateCryptoRecommendations(encryption: SecurityMetrics, hashing: SecurityMetrics, 
                                            password: SecurityMetrics): List<String> {
        val recommendations = mutableListOf<String>()
        
        if (encryption.throughput < 100) {
            recommendations.add("ÏïîÌò∏Ìôî ÏÑ±Îä•Ïù¥ ÎÇÆÏäµÎãàÎã§. ÌïòÎìúÏõ®Ïñ¥ Í∞ÄÏÜçÏùÑ ÌôúÏö©ÌïòÍ±∞ÎÇò Îçî Îπ†Î•∏ ÏïîÌò∏Ìôî Î∞©ÏãùÏùÑ Í≥†Î†§ÌïòÏÑ∏Ïöî.")
        }
        
        if (hashing.throughput < 1000) {
            recommendations.add("Ìï¥Ïã± ÏÑ±Îä• Í∞úÏÑ†ÏùÑ ÏúÑÌï¥ SHA-256 ÎåÄÏã† BLAKE2Î•º Í≥†Î†§Ìï¥Î≥¥ÏÑ∏Ïöî.")
        }
        
        if (password.throughput < 10) {
            recommendations.add("Ìå®Ïä§ÏõåÎìú Ïù∏ÏΩîÎî©Ïù¥ ÎÑàÎ¨¥ ÎäêÎ¶ΩÎãàÎã§. BCrypt rounds ÏàòÎ•º Ï°∞Ï†ïÌïòÍ±∞ÎÇò Argon2 ÏÇ¨Ïö©ÏùÑ Í≥†Î†§ÌïòÏÑ∏Ïöî.")
        }
        
        recommendations.add("ÎØºÍ∞êÌïú Îç∞Ïù¥ÌÑ∞Îäî AES-256-GCMÏúºÎ°ú ÏïîÌò∏ÌôîÌïòÍ≥†, Ìï¥ÏãúÎäî ÏÜîÌä∏Î•º ÏÇ¨Ïö©ÌïòÏÑ∏Ïöî.")
        recommendations.add("ÏïîÌò∏Ìôî ÌÇ§Îäî ÏïàÏ†ÑÌïú ÌÇ§ Í¥ÄÎ¶¨ ÏãúÏä§ÌÖúÏùÑ ÌÜµÌï¥ Í¥ÄÎ¶¨ÌïòÏÑ∏Ïöî.")
        
        return recommendations
    }
    
    private fun generateProtocolRecommendations(performanceDifference: Double): List<String> {
        val recommendations = mutableListOf<String>()
        
        if (performanceDifference > 50) {
            recommendations.add("HTTPS Ïò§Î≤ÑÌó§ÎìúÍ∞Ä ÌÅΩÎãàÎã§. HTTP/2ÎÇò TLS 1.3 ÏÇ¨Ïö©ÏùÑ Í≥†Î†§ÌïòÏÑ∏Ïöî.")
            recommendations.add("SSL ÏÑ∏ÏÖò Ïû¨ÏÇ¨Ïö©Í≥º OCSP StaplingÏùÑ ÌôúÏÑ±ÌôîÌïòÏÑ∏Ïöî.")
        } else if (performanceDifference > 20) {
            recommendations.add("HTTPS ÏÑ±Îä•ÏùÄ ÏñëÌò∏ÌïòÎÇò, Ïó∞Í≤∞ ÌíÄÎßÅÍ≥º Keep-AliveÎ•º ÏµúÏ†ÅÌôîÌïòÏÑ∏Ïöî.")
        }
        
        recommendations.add("CDNÏùÑ ÌôúÏö©ÌïòÏó¨ SSL Ï¢ÖÎ£å ÏßÄÏ†êÏùÑ ÏµúÏ†ÅÌôîÌïòÏÑ∏Ïöî.")
        recommendations.add("HSTSÏôÄ certificate pinningÏúºÎ°ú Î≥¥ÏïàÏùÑ Í∞ïÌôîÌïòÏÑ∏Ïöî.")
        
        return recommendations
    }
    
    private fun generateRateLimitRecommendations(throughputImpact: Double, memoryImpact: Long): List<String> {
        val recommendations = mutableListOf<String>()
        
        if (throughputImpact > 30) {
            recommendations.add("Rate Limiting Ïò§Î≤ÑÌó§ÎìúÍ∞Ä ÌÅΩÎãàÎã§. RedisÎ•º ÏÇ¨Ïö©Ìïú Î∂ÑÏÇ∞ Rate LimitingÏùÑ Í≥†Î†§ÌïòÏÑ∏Ïöî.")
        }
        
        if (memoryImpact > 10000) { // 10MB Ïù¥ÏÉÅ
            recommendations.add("Rate Limiting Î©îÎ™®Î¶¨ ÏÇ¨Ïö©ÎüâÏù¥ ÎÜíÏäµÎãàÎã§. ÎßåÎ£å Ï†ïÏ±ÖÏùÑ Í∞úÏÑ†ÌïòÏÑ∏Ïöî.")
        }
        
        recommendations.add("Token Bucket ÎåÄÏã† Sliding Window Î∞©ÏãùÏùÑ Í≥†Î†§Ìï¥Î≥¥ÏÑ∏Ïöî.")
        recommendations.add("ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏Î≥Ñ Ï∞®Îì± Rate LimitingÏùÑ Íµ¨ÌòÑÌïòÏÑ∏Ïöî.")
        
        return recommendations
    }
    
    private fun generateFilterChainRecommendations() {
        println("üéØ Security Filter Chain Optimization Recommendations:")
        println("   1. ÌïÑÏàò ÌïÑÌÑ∞Îßå ÌôúÏÑ±ÌôîÌïòÏó¨ ÏÑ±Îä• ÏµúÏ†ÅÌôî")
        println("   2. ÌïÑÌÑ∞ ÏàúÏÑú ÏµúÏ†ÅÌôî (Îπ†Î•∏ Í±∞Î∂Ä Ï°∞Í±¥ÏùÑ ÏïûÏ™ΩÏóê Î∞∞Ïπò)")
        println("   3. ÌïÑÌÑ∞Î≥Ñ ÎπÑÎèôÍ∏∞ Ï≤òÎ¶¨ Íµ¨ÌòÑ")
        println("   4. Ï∫êÏã±ÏùÑ ÌôúÏö©Ìïú Ï§ëÎ≥µ Í≤ÄÏ¶ù Î∞©ÏßÄ")
        println("   5. Ï°∞Í±¥Î∂Ä ÌïÑÌÑ∞ Ï†ÅÏö© (ÌäπÏ†ï ÏóîÎìúÌè¨Ïù∏Ìä∏ÏóêÎßå Ï†ÅÏö©)")
        println()
    }
    
    private fun generateComprehensiveRecommendations(jwt: JWTPerformanceResult, crypto: CryptoPerformanceResult,
                                                   protocol: ProtocolPerformanceResult, rateLimit: RateLimitingResult) {
        println("üîß COMPREHENSIVE OPTIMIZATION RECOMMENDATIONS")
        println("-" * 60)
        
        println("1. JWT ÏµúÏ†ÅÌôî:")
        jwt.recommendations.forEach { println("   ‚Ä¢ $it") }
        
        println("\n2. ÏïîÌò∏Ìôî ÏµúÏ†ÅÌôî:")
        crypto.recommendations.forEach { println("   ‚Ä¢ $it") }
        
        println("\n3. ÌîÑÎ°úÌÜ†ÏΩú ÏµúÏ†ÅÌôî:")
        protocol.recommendations.forEach { println("   ‚Ä¢ $it") }
        
        println("\n4. Rate Limiting ÏµúÏ†ÅÌôî:")
        rateLimit.recommendations.forEach { println("   ‚Ä¢ $it") }
        
        println("\n5. Ï†ÑÏ≤¥Ï†ÅÏù∏ Í∂åÏû•ÏÇ¨Ìï≠:")
        println("   ‚Ä¢ Î≥¥ÏïàÍ≥º ÏÑ±Îä•Ïùò Í∑†ÌòïÏ†êÏùÑ Ï∞æÏïÑ Ï†ÅÏ†àÌïú Î≥¥Ïïà ÏàòÏ§ÄÏùÑ ÏÑ§Ï†ïÌïòÏÑ∏Ïöî")
        println("   ‚Ä¢ Ï†ïÍ∏∞Ï†ÅÏù∏ Î≥¥Ïïà ÏÑ±Îä• Î™®ÎãàÌÑ∞ÎßÅÏùÑ Íµ¨ÌòÑÌïòÏÑ∏Ïöî")
        println("   ‚Ä¢ Î≥¥Ïïà Ï†ïÏ±ÖÏùÑ ÌôòÍ≤ΩÎ≥ÑÎ°ú Ï∞®Îì± Ï†ÅÏö©ÌïòÏÑ∏Ïöî (Í∞úÎ∞ú/Ïä§ÌÖåÏù¥Ïßï/ÌîÑÎ°úÎçïÏÖò)")
        println("   ‚Ä¢ Î≥¥Ïïà Ïò§Î≤ÑÌó§ÎìúÎ•º Í≥†Î†§Ìïú Ïù∏ÌîÑÎùº Ïö©Îüâ Í≥ÑÌöçÏùÑ ÏàòÎ¶ΩÌïòÏÑ∏Ïöî")
        println("   ‚Ä¢ Î≥¥Ïïà ÏÑ±Îä• Î©îÌä∏Î¶≠ÏùÑ Î™®ÎãàÌÑ∞ÎßÅ ÎåÄÏãúÎ≥¥ÎìúÏóê Ìè¨Ìï®ÏãúÌÇ§ÏÑ∏Ïöî")
    }
    
    // ============================================================
    // Í≤∞Í≥º Ï∂úÎ†• Î©îÏÑúÎìúÎì§
    // ============================================================
    
    private fun printJWTAnalysisResults(result: JWTPerformanceResult) {
        println("\nüìä JWT Performance Analysis Results:")
        println("-" * 50)
        
        with(result.tokenGeneration) {
            println("Token Generation:")
            println("  ‚Ä¢ Algorithm: $algorithm")
            println("  ‚Ä¢ Processing Time: ${operationTime}ms")
            println("  ‚Ä¢ Throughput: ${"%.2f".format(throughput)} tokens/sec")
            println("  ‚Ä¢ Success Rate: ${"%.2f".format((successCount.toDouble() / (successCount + errorCount)) * 100)}%")
        }
        
        with(result.tokenValidation) {
            println("\nToken Validation:")
            println("  ‚Ä¢ Processing Time: ${operationTime}ms")
            println("  ‚Ä¢ Throughput: ${"%.2f".format(throughput)} validations/sec")
            println("  ‚Ä¢ Success Rate: ${"%.2f".format((successCount.toDouble() / (successCount + errorCount)) * 100)}%")
        }
        
        with(result.tokenParsing) {
            println("\nToken Parsing:")
            println("  ‚Ä¢ Processing Time: ${operationTime}ms")
            println("  ‚Ä¢ Throughput: ${"%.2f".format(throughput)} parses/sec")
            println("  ‚Ä¢ Success Rate: ${"%.2f".format((successCount.toDouble() / (successCount + errorCount)) * 100)}%")
        }
        
        println("\nOverall JWT Performance:")
        println("  ‚Ä¢ Average Throughput: ${"%.2f".format(result.overallThroughput)} ops/sec")
        println("  ‚Ä¢ Memory Footprint: ${result.memoryFootprint / 1024}KB for 1000 tokens")
        
        performanceLog.addAll(listOf(result.tokenGeneration, result.tokenValidation, result.tokenParsing))
    }
    
    private fun printCryptoAnalysisResults(result: CryptoPerformanceResult) {
        println("\nüîí Cryptographic Performance Analysis Results:")
        println("-" * 50)
        
        with(result.encryptionMetrics) {
            println("AES Encryption (${algorithm}):")
            println("  ‚Ä¢ Processing Time: ${operationTime}ms")
            println("  ‚Ä¢ Throughput: ${"%.2f".format(throughput)} ops/sec")
            println("  ‚Ä¢ Data Size: ${dataSize} bytes")
        }
        
        with(result.decryptionMetrics) {
            println("\nAES Decryption (${algorithm}):")
            println("  ‚Ä¢ Processing Time: ${operationTime}ms")
            println("  ‚Ä¢ Throughput: ${"%.2f".format(throughput)} ops/sec")
        }
        
        with(result.hashingMetrics) {
            println("\nBest Hashing Algorithm (${algorithm}):")
            println("  ‚Ä¢ Processing Time: ${operationTime}ms")
            println("  ‚Ä¢ Throughput: ${"%.2f".format(throughput)} hashes/sec")
        }
        
        with(result.passwordMetrics) {
            println("\nPassword Encoding (${algorithm}):")
            println("  ‚Ä¢ Processing Time: ${operationTime}ms")
            println("  ‚Ä¢ Throughput: ${"%.2f".format(throughput)} encodings/sec")
        }
        
        println("\nOverall Crypto Score: ${"%.2f".format(result.overallScore)}/100")
        
        performanceLog.addAll(listOf(result.encryptionMetrics, result.decryptionMetrics, 
                                   result.hashingMetrics, result.passwordMetrics))
    }
    
    private fun printProtocolAnalysisResults(result: ProtocolPerformanceResult) {
        println("\nüåê Protocol Performance Analysis Results:")
        println("-" * 50)
        
        with(result.httpMetrics) {
            println("HTTP Performance:")
            println("  ‚Ä¢ Processing Time: ${operationTime}ms")
            println("  ‚Ä¢ Throughput: ${"%.2f".format(throughput)} req/sec")
        }
        
        with(result.httpsMetrics) {
            println("\nHTTPS Performance (${algorithm}):")
            println("  ‚Ä¢ Processing Time: ${operationTime}ms")
            println("  ‚Ä¢ Throughput: ${"%.2f".format(throughput)} req/sec")
        }
        
        println("\nProtocol Comparison:")
        println("  ‚Ä¢ Performance Difference: ${"%.2f".format(result.performanceDifference)}%")
        println("  ‚Ä¢ Security Overhead: ${"%.2f".format(result.securityOverhead)}ms")
        
        if (result.performanceDifference < 10) {
            println("  ‚Ä¢ ‚úÖ HTTPS Ïò§Î≤ÑÌó§ÎìúÍ∞Ä Ï†ÅÏ†àÌï©ÎãàÎã§")
        } else if (result.performanceDifference < 30) {
            println("  ‚Ä¢ ‚ö†Ô∏è HTTPS Ïò§Î≤ÑÌó§ÎìúÍ∞Ä Îã§ÏÜå ÎÜíÏäµÎãàÎã§")
        } else {
            println("  ‚Ä¢ ‚ùå HTTPS Ïò§Î≤ÑÌó§ÎìúÍ∞Ä Îß§Ïö∞ ÎÜíÏäµÎãàÎã§")
        }
        
        performanceLog.addAll(listOf(result.httpMetrics, result.httpsMetrics))
    }
    
    private fun printRateLimitAnalysisResults(result: RateLimitingResult) {
        println("\n‚è±Ô∏è Rate Limiting Impact Analysis Results:")
        println("-" * 50)
        
        with(result.rateLimitOverhead) {
            println("Rate Limiting Performance:")
            println("  ‚Ä¢ Algorithm: ${algorithm}")
            println("  ‚Ä¢ Processing Time: ${operationTime}ms")
            println("  ‚Ä¢ Throughput: ${"%.2f".format(throughput)} req/sec")
            println("  ‚Ä¢ Success Rate: ${"%.2f".format((successCount.toDouble() / (successCount + errorCount)) * 100)}%")
            println("  ‚Ä¢ Blocked Requests: ${errorCount}")
        }
        
        println("\nImpact Analysis:")
        println("  ‚Ä¢ Throughput Impact: ${"%.2f".format(result.throughputImpact)}%")
        println("  ‚Ä¢ Memory Impact: ${result.memoryImpact}KB")
        println("  ‚Ä¢ Latency Increase: ${"%.2f".format(result.latencyIncrease)}ms")
        
        if (result.throughputImpact < 10) {
            println("  ‚Ä¢ ‚úÖ Rate Limiting Ïò§Î≤ÑÌó§ÎìúÍ∞Ä Ï†ÅÏ†àÌï©ÎãàÎã§")
        } else if (result.throughputImpact < 30) {
            println("  ‚Ä¢ ‚ö†Ô∏è Rate Limiting Ïò§Î≤ÑÌó§ÎìúÍ∞Ä Îã§ÏÜå ÎÜíÏäµÎãàÎã§")
        } else {
            println("  ‚Ä¢ ‚ùå Rate Limiting Ïò§Î≤ÑÌó§ÎìúÍ∞Ä Îß§Ïö∞ ÎÜíÏäµÎãàÎã§")
        }
        
        performanceLog.add(result.rateLimitOverhead)
    }
    
    // ============================================================
    // Î≥¥Í≥†ÏÑú ÏÉùÏÑ±
    // ============================================================
    
    private fun generatePerformanceReport() {
        val timestamp = LocalDateTime.now().format(DateTimeFormatter.ofPattern("yyyy-MM-dd_HH-mm-ss"))
        val reportPath = "/Users/anb-28/Reservation/reports/security-performance-report-$timestamp.csv"
        
        // Î≥¥Í≥†ÏÑú ÎîîÎ†âÌÜ†Î¶¨ ÏÉùÏÑ±
        val reportDir = java.io.File("/Users/anb-28/Reservation/reports")
        if (!reportDir.exists()) {
            reportDir.mkdirs()
        }
        
        // CSV Î≥¥Í≥†ÏÑú ÏÉùÏÑ±
        val csvContent = StringBuilder()
        csvContent.appendLine("Timestamp,Operation Type,Algorithm,Key Size,Data Size,Operation Time (ms),Throughput (ops/sec),Memory Used (KB),CPU Intensive,Success Count,Error Count")
        
        performanceLog.forEach { metric ->
            csvContent.appendLine("${metric.timestamp},${metric.operationType},${metric.algorithm},${metric.keySize},${metric.dataSize},${metric.operationTime},${"%.2f".format(metric.throughput)},${metric.memoryUsed},${metric.cpuIntensive},${metric.successCount},${metric.errorCount}")
        }
        
        java.io.File(reportPath).writeText(csvContent.toString())
        
        println("\nüìã Performance Report Generated:")
        println("   Location: $reportPath")
        println("   Total Metrics: ${performanceLog.size}")
        println("   Analysis Complete! üéâ")
    }
}