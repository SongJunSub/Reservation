# Spring WebFlux와 리액티브 프로그래밍

## WebFlux vs Spring MVC

| 특성 | Spring MVC | Spring WebFlux |
|------|------------|----------------|
| 모델 | 블로킹 I/O | 논블로킹 I/O |
| 스레드 | 요청당 스레드 | 이벤트 루프 |
| 처리량 | 높은 지연시간 | 높은 동시성 |
| 백프레셔 | 지원 안함 | 지원 |

## 핵심 개념

### Mono vs Flux
```kotlin
// 단일 값 또는 빈 값
val mono: Mono<String> = Mono.just("Hello")

// 0...N개의 값 스트림  
val flux: Flux<String> = Flux.just("A", "B", "C")
```

### 백프레셔 (Backpressure)
- 생산자가 소비자보다 빠를 때의 압력 제어
- 메모리 오버플로우 방지
- 요청량 기반 제어

## 실무에서의 활용

### 언제 사용?
1. **높은 동시성**이 필요한 경우
2. **네트워크 I/O**가 많은 경우  
3. **스트리밍 데이터** 처리
4. **마이크로서비스** 간 통신

### 주의사항
1. **블로킹 코드 금지**: JDBC, 동기 HTTP 클라이언트
2. **스레드풀 격리**: 블로킹 작업은 별도 스레드풀
3. **디버깅 어려움**: 스택 트레이스 복잡
4. **학습 곡선**: 리액티브 사고방식 필요

## 호스피탈리티 예약 시스템에서의 활용
- 다중 호텔 검색 API 병렬 호출
- 실시간 객실 가용성 스트리밍
- 예약 확정 시 여러 외부 시스템 동시 호출